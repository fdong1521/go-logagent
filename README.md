# 采用go语言开发高性能日志采集系统

# 一、项目背景
    
      在大数据分析领域，最重要的就是数据，而日志作为首选数据来源之一，有着举足轻重的地位，如今企业的线上业务服务器，少则几十台上百台，
      多则上千台，这么多台线上服务器，按照每台每天平均产生出50G的日志来算，如果线上共有100台服务器，则每天就可以产生差不多5TB的日志量
      ，而将些日志流数据高效可靠的写入hdfs，我们应该怎么做？有人会说每台业务服务器自己往HDFS写啊，no,no,no，这样做的话hdfs表示受不了
      ，我们一定要考虑到“供需稳定和平衡”
      
      本人将要开发一套通用大数据平台，并将其开源，供大家学习交流、也非期待有意愿参与这个项目开发同学加入，其主要包括数据采集、数据仓库、
      数据挖掘、自然语言处理、智能推荐系统、报表展现
      
      目前常用的开源日志收集系统有Flume, Scribe等。
      Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，目前已经是Apache的一个子项目。
      Scribe是Facebook开源的日志收集系统，它为日志的分布式收集，统一处理提供一个可扩展的，高容错的简单方案。
      Flume是用Java语言开发、Scribe是用c/c++开发
      
      go-logagent这个项目是日志采集系统、主要用golang开发，其主要是做日志收集工作
        
# 二、设计原则
      既然我们要做日志采集，那么我们需要重点考虑是哪几个技术指标
   **第一，效率和性能**
      如果一条数据秒级延迟，我们可以接受，如果线上一条日志几十秒才到数据仓库，我觉得这样系统需要改进。我们最想要效果
      是原始数据秒级采集并存储数据仓库。</br>
   **第二、可靠性**
      我们都知道只要经过网络传输的数据，会存在数据丢失可能性，我们要保证发生故障后，故障快速转移与恢复，我们要保证一
      条消息不被重复消费</br>
   **第三、可扩展性**
      动态扩展是分布式系统重要指标之一，如果日志剧增，我们可以动态增加节点来增大吞吐量<br/>
   **第四、异构源**
      日志不仅只需要传送到hdfs，某些日志可能要送到redis、本地文件、mysql、monogodb、hbase、hive，我们希望可以通过简
      单配置就可实现不同目地的日志传送
      
      

# 三、技术选型
      
      开发语言:GoLang
      
      分布式消息队中间件:kafka
      
      分布式配置中间件:etcd
      
      分布式协调中间件:zookeeper
      
      关系型数据库:mysql

# 四、整体架构

![日志集采架构图](https://raw.githubusercontent.com/fdong1521/go-logagent/master/img-doc/%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%99%A8%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

# 五、数据表设计
**1.主机节点表 t_logagent_node**</br>
  主机节点表用于存储需要采集日志的主机信息 
  
| 字段| 类型 | 描述 |
| :-------------- | :---------------- | :------------------------ |
| id | int | 主键 |
| key_path | varchar(255) | 关键路径 |
| server_name | varchar(255) | 服务名称 |
| ip |  varchar(16) | 主机内网ip |
| create_time | varchar(32) | 创建时间 |

**2.日志文件配置表 t_logagent_tail**</br>
    日志文件配置表用于存储需要采集日志对象的信息    

| 字段| 类型 | 描述 |
| :-------------- | :---------------- | :--------------------------- |
| id | int | 主键 |
| log_path | varchar(255) | 日志路径 |
| topic | varchar(255) | 消息主题 |
| node_id |  varchar(16) | 主机节点 |
| status | varchar(32) | 状态（ 0:停止 1:运行） |
| create_time | varchar(32) | 创建时间 |



# 六、项目部署




# 七、总结
